# 아키텍처 리뷰: TradingEngine 초기화 순서 및 컴포넌트 주입 설계

**날짜:** 2025-12-21 11:00:39
**주제:** `TradingEngine.__init__` 내 핸들러 등록 지점과 컴포넌트(Strategy, Collector 등) 주입 순서의 타당성 검토

---

## 1. 검토 배경

`TradingEngine`의 사용 예시를 보면 `__init__` 단계에서 `_setup_handlers()`를 통해 이벤트 핸들러를 등록합니다. 이때 콜렉터, 전략, 오더 매니저 등 실제 작업에 필요한 컴포넌트들이 아직 주입(Dependency Injection)되지 않은 상태(None)임에도 핸들러 등록이 먼저 수행되는 것이 설계상의 오류가 아닌지 검토가 필요합니다.

---

## 2. 분석 결과 (오류 여부 및 설계 타당성)

결론적으로, 현재의 순서는 **정상적인 설계이며 이벤트 기반 아키텍처의 의도된 결과**입니다.

### 2.1 등록과 실행의 분리 (Decoupling)
- `_setup_handlers()`는 메서드의 **참조(Reference)**를 `EventBus`에 등록할 뿐입니다.
- 등록 시점에 해당 메서드 내부에서 참조하는 컴포넌트(`self.strategy` 등)가 `None`이어도 실행 시점이 아니므로 오류가 발생하지 않습니다.

### 2.2 라이프사이클 관리 (`run()` 메서드)
- 이벤트가 실제로 발생하고 소비되기 시작하는 시점은 `await engine.run()`이 호출된 이후입니다.
- 사용자는 `run()`을 호출하기 전 단계에서 필요한 모든 컴포넌트를 주입하게 되므로, 실제 핸들러가 호출되는 시점에는 유효한 객체가 존재하게 됩니다.

### 2.3 방어적 프로그래밍 (Defensive Programming)
- 각 핸들러(`_on_candle_closed`, `_on_signal` 등)는 내부적으로 컴포넌트 존재 여부를 체크하도록 설계되어 있습니다.
- 만약 주입이 누락된 상태에서 이벤트가 유입되더라도 시스템이 중단되는 대신 경고 로그를 남기고 안전하게 이벤트를 무시합니다.

---

## 3. 설계의 장점

이러한 **'선 등록 후 주입'** 방식은 다음과 같은 이점을 제공합니다.

- **느슨한 결합 (Loose Coupling)**: 엔진의 기본 구조와 실제 구동 로직을 분리하여 유연성을 높입니다.
- **테스트 용이성 (Testability)**: 실제 라이브 환경뿐만 아니라 테스트 환경에서도 동일한 이벤트 파이프라인을 유지한 채 다양한 Mock 객체를 자유롭게 갈아 끼울 수 있습니다.
- **유연한 모드 전환**: 전략이나 오더 매니저 없이 특정 컴포넌트(예: 데이터 수집 전용)만 구동하는 경우에도 코드 수정 없이 대응이 가능합니다.

---

## 4. 결론

현재의 초기화 및 주입 순서는 이벤트 기반 시스템의 유연성과 안정성을 모두 고려한 올바른 구조입니다. 컴포넌트 주입은 `run()` 호출 이전에만 완료되면 시스템 작동에 문제가 없음을 확인하였습니다.
