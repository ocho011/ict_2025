# 아키텍처 분석: 독립적 저장소(Buffer/Queue) 설계의 적절성

현재 프로젝트에서 `Candle` 데이터와 이벤트 결과물을 처리하기 위해 여러 컴포넌트(`DataCollector`, `EventBus`, `BaseStrategy`, `OrderManager`)가 각각 독립적인 저장소나 버퍼를 유지하는 설계에 대해 분석한 결과입니다.

## 1. 현황 확인
분석 결과, 실제로 다음과 같은 계층에서 데이터가 관리되고 있습니다.
- **`BinanceDataCollector`**: 각 심볼/타임프레임별로 최신 N개의 캔들을 `deque`에 캐싱 (`_candle_buffers`).
- **`EventBus`**: 비동기 처리를 위해 3개의 우선순위 큐(`data`, `signal`, `order`)를 통해 이벤트를 전달.
- **`BaseStrategy`**: 개별 전략별로 지표 계산에 필요한 과거 데이터를 `candle_buffer` (List)에 저장.
- **`OrderExecutionManager`**: 실행 중인 주문들을 심볼별로 추적 (`_open_orders`).

## 2. 설계의 목적 및 이점

이러한 "독립적 저장소" 설계는 다음과 같은 명확한 목적이 있습니다.

### ① 결합도 분리 (Decoupling)와 유연성
- **생명주기 독립**: `DataCollector`가 가동 중이더라도 특정 전략을 중간에 켜거나 끌 수 있습니다. 각 전략은 자신이 시작된 시점부터 필요한 만큼의 데이터를 독립적으로 관리합니다.
- **Lookback 기간의 차이**: 전략 A는 20일 이동평균선(20개 캔들)이 필요하고, 전략 B는 200일 이동평균선(200개 캔들)이 필요할 수 있습니다. 중앙 저장소 하나에서 이를 관리하면 가장 긴 기간에 맞춰 모든 데이터를 유지해야 하므로 오히려 관리가 복잡해집니다.

### ② 이벤트(Event) vs 상태(State)의 분리
- **`EventBus`**는 '지금 막 발생한 일'을 전달하는 **통로(Transient)**입니다.
- **`Buffer`**는 과거의 흐름을 파악하기 위한 **상태(Persistent Context)**입니다.
- 두 개념을 분리함으로써 `EventBus`는 전달 기능에만 집중하여 성능을 극대화할 수 있습니다.

### ③ 상태 격리 (State Isolation)
- Python의 객체는 참조로 전달되지만, 전략이 데이터를 가공하거나 특정 속성을 임시로 추가할 때 다른 전략에 영향을 주지 않도록 격리된 뷰(View)를 제공합니다.

---

## 3. 자원 중복 소요에 대한 정밀 분석

### ▣ 메모리 측면 (Memory Efficiency)
- **객체 참조 (Reference Passing)**: Python은 모든 객체를 참조 방식으로 다룹니다. `Candle` 객체 하나가 생성되면, `DataCollector`, `EventBus`, `Strategy`의 버퍼들은 모두 동일한 메모리 주소를 가리키는 **'포인터'**만을 가집니다.
- **실제 비용**: 1,000개의 캔들에 대한 참조 리스트는 약 8KB 내외입니다. 10개의 가동 중인 전략이 있더라도 추가 메모리 소요는 수백 KB 수준으로, 현대적 인프라에서는 **무시할 수 있는 수준**입니다. 실제 데이터(실수, 문자열 등)는 메모리에 단 하나만 존재합니다.

### ▣ 연산 측면 (Computational Overhead)
- **중복 계산**: 동일한 지표(예: SMA 20)를 여러 전략이 각각 계산한다면 이는 자원 낭비가 맞습니다.
- **해결 방안**: 현재 규모(MVP)에서는 영향이 미미하나, 전략이 수십 개로 늘어난다면 '공유 지표 서비스'를 통해 계산 결과를 이벤트로 배포하는 방식이 권장됩니다.

---

## 4. 결론 및 향후 방향

### 적절성 평가: **매우 적절함 (Highly Appropriate)**
현재의 MVP 단계에서는 **복잡성을 낮추고 확장성을 확보**하는 것이 자원 최적화보다 훨씬 중요합니다. 독립적인 버퍼 설계는 전략을 개별적으로 테스트(Unit Test)하거나 백테스팅 엔진에 끼워넣기 매우 유리한 구조입니다.

### 향후 최적화 가능성
만약 리소스 소요가 문제가 되는 시점(수천 개의 전략 동시 구동 등)이 온다면 다음과 같은 개선을 고려할 수 있습니다.
1. **Shared Memory Cache**: 중앙에서 관리되는 읽기 전용 캔들 저장소 제공.
2. **Indicator Event Enrichment**: 자주 쓰이는 지표 계산 결과를 `CANDLE_CLOSED` 이벤트에 포함하여 전달.

현재의 설계는 **"의도된 중복(Intentional Redundancy)"**을 통해 **"아키텍처의 견고함(Robustness)"**을 얻는 올바른 트레이드오프라고 판단됩니다.
