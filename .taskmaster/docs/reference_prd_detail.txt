제품 요구사항 정의서 (PRD): 바이낸스 USDT 무기한 선물 자동매매 시스템 (상세 버전)

1. Overview (개요)

이 문서는 바이낸스 USDT 무기한 선물 시장을 위한 자동매매 시스템의 제품 요구사항을 정의합니다. 본 시스템은 사용자가 직접 정의한 매매 전략을 기반으로 24시간 자동으로 거래를 실행하여, 감정적 개입으로 인한 비합리적인 판단과 손실을 최소화하는 것을 목표로 합니다.

주요 대상 사용자는 파이썬 코드와 객체 지향 개념에 대한 이해가 있고 거래소 API 연동 경험은 있으나, 직접 전체 매매 스크립트를 처음부터 작성해 본 경험은 적은 '비전문 개발자'입니다.

본 시스템의 핵심 가치는 ICT(Inner Circle Trader) 이론에 기반한 다양한 기술적 지표들을 조합하여 사용자 맞춤형 전략을 손쉽게 생성하고 자동화할 수 있도록 지원하는 것입니다. 이를 통해 사용자는 복잡한 시장 분석과 반복적인 주문 실행 과정에서 벗어나, 자신의 아이디어를 체계적으로 검증하고 안정적인 자동매매 환경을 구축할 수 있습니다.

2. Core Features (핵심 기능)
2.1 ICT 전략 엔진 (ICT Strategy Engine)

What it does (무엇을 하는가):
실시간 캔들 데이터(웹소켓)를 기반으로 FVG, Order Block, Breaker Block, Liquidity Pool, Market Structure 등 주요 ICT 지표 값을 '정확하고 신뢰성 있게' 계산합니다. 이 단위 지표들을 사전에 정의된 로직에 따라 조합하여 구체적인 매매 신호(진입, 익절, 손절)를 생성합니다.

Why it's important (왜 중요한가):
시스템의 두뇌 역할을 하는 핵심 기능입니다. 감정이나 주관이 배제된, 100% ICT 이론에 입각한 체계적인 매매 판단을 내리는 근거를 제공합니다. 또한, 향후 다양한 전략을 추가할 수 있는 확장성의 기반이 됩니다.

How it works (어떻게 동작하는가):

바이낸스 웹소켓으로부터 실시간 캔들 데이터를 수신합니다.

수신된 데이터를 바탕으로 각 ICT 단위 지표(FVG, OB 등)를 계산하고 업데이트합니다.

사용자가 선택한 특정 전략 로직(예: '시장가 진입 전략 A', '지정가 진입 전략 B')에 따라 단위 지표들의 조건을 확인합니다.

조건이 충족되면, 진입 가격, 포지션 방향(롱/숏), 그리고 지표 기반의 목표 익절가(TP)와 손절가(SL)를 포함한 매매 신호를 생성하여 '자동매매 실행 모듈'에 전달합니다.

초기 단계에서는 티커와 포지션(롱/숏) 단위로 하나의 전략만 적용하여 운영 복잡성을 최소화합니다.

2.2 실거래 및 시뮬레이션 실행 모듈 (Live Trading & Simulation Module)

What it does (무엇을 하는가):
'ICT 전략 엔진'으로부터 받은 매매 신호를 바탕으로 실제 바이낸스 계좌에 주문을 실행합니다. 사용자의 선택에 따라 메인넷(실거래) 또는 테스트넷(모의거래) 환경에서 동작할 수 있습니다.

Why it's important (왜 중요한가):
전략을 실제 시장에서 실행하는 역할을 담당합니다. 특히 별도의 백테스팅 기능 대신 테스트넷 연동을 통해, 실제 시장 환경과 거의 동일한 조건(슬리피지, 지연 등)에서 전략의 실효성을 검증하는 현실적인 시뮬레이션 환경을 제공합니다.

How it works (어떻게 동작하는가):

사용자의 API 키를 안전하게 저장하고 바이낸스 거래소 서버와 연결합니다.

설정 파일(e.g., config.ini) 등을 통해 메인넷/테스트넷 환경을 선택할 수 있는 옵션을 제공합니다.

매매 신호를 수신하면, 사전에 정의된 '리스크 관리' 설정에 따라 주문 수량, 레버리지 등을 계산하여 API를 통해 주문(진입, TP, SL)을 전송합니다.

주문 체결 상태를 지속적으로 추적하고 관리합니다.

2.3 지능형 리스크 관리 모듈 (Intelligent Risk Management Module)

What it does (무엇을 하는가):
사용자의 자본을 보호하기 위한 자동화된 리스크 관리 규칙을 적용합니다. 이는 개별 거래의 손익 관리뿐만 아니라, 전체 계좌의 안정성을 유지하는 역할을 합니다.

Why it's important (왜 중요한가):
수익 창출만큼이나 중요한 자본 보호를 자동화합니다. 감정적 대응(예: 손절을 미루거나, 불타기)을 원천적으로 차단하여 꾸준하고 안정적인 시스템 운영을 가능하게 합니다.

How it works (어떻게 동작하는가):

포지션 규모 설정: 사용자는 전체 시드의 특정 비율(예: 1회 거래 시 1% 손실 제한) 또는 고정 금액을 기준으로 진입 규모를 설정할 수 있습니다. 시스템은 이 설정과 손절가(SL)를 바탕으로 계약 수량을 자동으로 계산합니다.

레버리지 설정: 거래할 티커에 대한 레버리지를 사전에 설정합니다.

지표 기반 SL/TP: 매매 신호 생성 시 ICT 지표에 따라 결정된 명확한 손절가와 목표 익절가로 주문이 자동 설정됩니다.

최대 동시 포지션 제한: 동시에 진입할 수 있는 최대 포지션 수를 제한하여 과도한 노출(exposure)을 방지합니다.

2.4 모니터링 및 제어 인터페이스 (Monitoring & Control Interface)

What it does (무엇을 하는가):
자동매매 시스템의 현재 상태, 거래 내역, 손익 현황, 시스템 로그 등을 사용자에게 보여주고, 일부 설정을 변경할 수 있는 인터페이스를 제공합니다.

Why it's important (왜 중요한가):
사용자가 시스템의 작동 현황을 명확히 파악하고 신뢰할 수 있게 해줍니다. 문제가 발생했을 때 원인을 빠르게 파악하고 대응할 수 있도록 돕습니다.

How it works (어떻게 동작하는가):

초기 개발 단계 (MVP):

터미널(콘솔)에 실시간으로 현재 상태(대기 중, 포지션 진입 등), 포지션 정보(티커, 방향, 진입가, 수량), 실현 손익, 주요 이벤트(신호 발생, 주문 체결 등)를 출력합니다.

모든 상세 내역은 파일(e.g., log.txt)로 기록하여 사후 분석이 가능하게 합니다.

추후 고도화 단계:

웹 기반의 대시보드를 통해 모든 정보를 시각적으로 깔끔하게 제공합니다.

대시보드에서 직접 봇을 시작/중지하거나 리스크 관리 설정(예: 1회 거래 시 손실 허용률)을 변경하는 기능을 추가합니다.

3. User Experience (사용자 경험)
3.1 User Personas (사용자 페르소나)

이름: 김개발

역할: 비전문 개발자 (Hobbyist Developer)

기술 수준:

파이썬 기본 문법과 객체지향 개념을 이해하고 있음.

거래소 API 문서를 읽고 연동해 본 경험이 있음.

pip를 사용해 라이브러리를 설치하고 관리할 수 있음.

Pycharm과 같은 IDE 환경에 익숙함.

전체 자동매매 스크립트를 처음부터 끝까지 설계하고 작성해 본 경험은 부족함.

목표:

자신이 이해하고 있는 ICT 매매 아이디어를 시스템으로 구현하고 싶다.

감정적인 매매에서 벗어나, 시스템이 24시간 원칙대로 거래해주기를 원한다.

복잡한 인프라 설정이나 프레임워크 학습 없이, 핵심 전략 로직에 집중하고 싶다.

테스트넷을 통해 자신의 전략이 실제 시장에서 어떻게 동작하는지 안전하게 확인하고 싶다.

3.2 Key User Flows (주요 사용자 흐름)

김개발 님이 시스템을 처음 설정하고 실행하는 과정은 다음과 같습니다.

초기 환경 설정 (Initial Setup):
Git Repository에서 프로젝트를 로컬 컴퓨터로 복제(Clone)합니다. Pycharm과 같은 IDE로 프로젝트를 열고, requirements.txt 파일을 이용해 pip install -r requirements.txt 명령어로 필요한 파이썬 라이브러리를 한 번에 설치합니다.

계정 및 시스템 설정 (Account & System Configuration):
프로젝트 내 configs 폴더로 이동합니다. api_keys.ini (가칭) 파일을 열어 자신의 바이낸스 API 키와 시크릿 키를 입력합니다. is_testnet = true 또는 false 옵션을 통해 메인넷과 테스트넷 환경을 선택합니다. 이 api_keys.ini 파일은 .gitignore에 등록되어 있어 Git에 실수로 올라가지 않도록 관리됩니다.

매매 전략 및 리스크 설정 (Trading Strategy & Risk Configuration):
trading_config.ini (가칭) 파일을 엽니다. [Strategy] 섹션에서 거래할 티커(예: symbol = BTCUSDT)와 적용할 ICT 전략(예: strategy_name = FVG_Market_Entry_v1)을 선택하여 입력합니다. [RiskManagement] 섹션에서 레버리지(예: leverage = 10), 1회 거래당 허용 손실률(예: loss_per_trade_percent = 1.0), 최대 동시 진입 포지션 수(예: max_positions = 2) 등의 리스크 관리 조건을 설정합니다.

시스템 실행 및 모니터링 (Execution & Monitoring):
IDE의 실행(Run) 버튼을 누르거나 터미널에서 python main.py 명령어를 입력하여 시스템을 시작합니다. 콘솔(터미널) 창에 시스템의 현재 상태(초기화, 데이터 수신 중, 신호 대기 중 등)가 실시간으로 출력됩니다. 매매 신호가 발생하거나 주문이 체결되면, 관련 정보(진입 시간, 티커, 가격, 손익 등)가 로그로 출력되어 진행 상황을 명확히 확인할 수 있습니다.

설정 변경 및 재시작 (Modification & Restart):
실행 중인 시스템을 Ctrl+C로 중지하고, trading_config.ini 파일을 수정하여 다른 전략을 테스트하거나 리스크 설정을 변경한 후 시스템을 다시 실행하여 변경된 설정으로 자동매매를 재개합니다.

서버 배포 (Deployment to Server):
로컬 환경에서 충분한 테스트와 검증이 끝나면, Vultr와 같은 클라우드 서버에 프로젝트 파일을 업로드하고 nohup python main.py & 와 같은 명령어를 사용해 24시간 동작하도록 시스템을 실행합니다.

3.3 UI/UX Considerations (UI/UX 고려사항)

MVP 단계: 모든 설정과 모니터링은 설정 파일(.ini) 수정과 터미널 로그를 통해 이루어집니다. 이는 개발 초기 단계에서 UI 개발에 드는 리소스를 최소화하고 핵심 로직 구현에 집중하기 위함입니다.

미래 단계 (Post-MVP): 추후 웹 기반의 대시보드 UI를 도입할 것을 고려합니다. 사용자는 웹 브라우저를 통해 ▲실시간 손익 현황, ▲포지션 정보, ▲시스템 로그를 시각적으로 확인하고, ▲UI 상에서 간편하게 전략과 리스크 설정을 변경할 수 있게 됩니다.

4. Technical Architecture (기술 아키텍처)
4.1 System Components (시스템 구성 요소)

본 시스템은 모듈식 설계를 통해 각 컴포넌트가 독립적으로 작동하고, 서로 유기적으로 상호작용하는 구조를 가집니다.

데이터 수집기 (Data Collector): binance-futures-connector 라이브러리의 웹소켓 클라이언트를 사용하여 지정된 티커의 캔들 데이터와 사용자 데이터를 구독하고 수신하여 내부 이벤트 큐로 전달합니다.

이벤트 처리 시스템 (Event Handling System): 이벤트 재밍(Jamming) 문제 해결을 위해 목적에 따라 다중 큐(Multi-Queue) 아키텍처를 적용합니다.

데이터 큐 (Data Queue): 실시간 캔들 데이터를 담는 큐.

신호 큐 (Signal Queue): 전략 엔진이 생성한 매매 신호를 담는 큐.

주문 큐 (Order Queue): 실행 모듈이 바이낸스로 보낼 주문 요청 및 체결 결과를 담는 큐.
각 큐는 독립적인 이벤트 루프에서 처리되어 특정 작업이 다른 중요한 작업을 막는 것을 방지합니다. Python의 asyncio와 asyncio.Queue를 활용하여 비동기 방식으로 효율적으로 이벤트를 처리합니다.

ICT 전략 엔진 (ICT Strategy Engine): '데이터 큐'에서 캔들 데이터를 가져와 pandas, numpy를 활용하여 ICT 지표를 계산하고, 정의된 전략에 따라 매매 신호를 생성합니다. 전략 로직은 클래스 형태로 모듈화하여 향후 확장이 용이하도록 설계합니다.

주문 실행 관리자 (Order Execution Manager): '신호 큐'에서 매매 신호를 받아 리스크 관리 규칙에 따라 최종 주문을 결정하고, '주문 큐'의 요청을 실제 바이낸스 REST API 호출로 변환하여 주문을 전송하고, 체결 결과를 관리합니다. API 요청 실패 시 재시도 로직, 에러 핸들링 등 안정성을 위한 방어적 프로그래밍을 포함합니다.

모니터링 및 로깅 (Monitoring & Logging): Python의 내장 logging 모듈을 사용하여 파일 및 콘솔에 시스템의 모든 주요 활동과 상태를 기록합니다. 로그 레벨(DEBUG, INFO, WARNING, ERROR)을 구분하여 문제 발생 시 원인 추적을 용이하게 합니다.

4.2 Data Models (데이터 모델)

객체지향 설계를 기반으로 시스템 내에서 사용될 핵심 데이터 구조를 클래스로 정의합니다.

Event: 이벤트 종류와 데이터를 담는 기본 클래스

Candle: 시가, 고가, 저가, 종가, 거래량 등 OHLCV 데이터를 포함

Signal: 티커, 방향(LONG/SHORT), 진입 유형(MARKET/LIMIT), 목표가(TP), 손절가(SL) 등의 정보를 포함

Position: 현재 보유 중인 포지션의 상태 (진입 가격, 수량, 미실현 손익 등)

Order: 주문 ID, 상태(NEW, FILLED, CANCELED), 체결 가격 등의 정보를 포함

4.3 APIs and Integrations (API 및 통합)

Primary API: Binance USDT-M Futures API

Library: binance-futures-connector (웹소켓 및 REST API 통신용)

4.4 Infrastructure Requirements (인프라 요구사항)

Development: OS: Windows, macOS, or Linux / Python Version: 3.9+ / IDE: Pycharm

Production: Cloud Provider: Vultr, AWS EC2 등 / OS: Linux (Ubuntu 22.04 LTS 권장) / Instance: 최소 1 vCPU, 1 GB RAM

5. Development Roadmap (개발 로드맵)
Phase 1: Core Engine - End-to-End 최소 기능 구현 (MVP의 MVP)

목표: 데이터 수신부터 주문 실행까지, 가장 단순한 형태로 전체 흐름(End-to-End)을 완성하여 시스템의 뼈대가 정상 동작함을 증명합니다.

세부 스코프:

[1-1] Binance API 연결 및 데이터 스트리밍: binance-futures-connector를 이용해 특정 티커의 캔들 데이터를 웹소켓으로 받아와 콘솔에 출력합니다.

[1-2] Mock 전략 엔진 및 신호 생성: 매우 단순한 로직(예: '양봉 3개 연속 시 롱')으로 매매 신호를 생성하여 콘솔에 출력합니다.

[1-3] 기본 주문 실행 모듈: 생성된 신호를 받아 바이낸스 테스트넷에 시장가로 고정된 최소 수량의 주문을 실행합니다.

Phase 2: ICT 지표 및 지능형 리스크 관리 도입

목표: MVP의 뼈대에 핵심 비즈니스 로직인 ICT 지표 계산과 자본 보호를 위한 리스크 관리 기능을 추가합니다.

세부 스코프:

[2-1] 핵심 ICT 단위 지표 계산기 구현: FVG, Order Block 등 핵심 ICT 지표 1~2개를 계산하는 로직을 구현합니다.

[2-2] ICT 기반 실제 전략 구현 (1차): 계산된 ICT 지표를 조합한 시장가 매매 전략을 구현하고, 신호 생성 시 지표 기반 SL/TP 가격을 함께 반환하도록 합니다.

[2-3] 지능형 리스크 관리 모듈 구현: loss_per_trade_percent 설정과 SL 가격을 바탕으로 진입할 계약 수량을 자동 계산하는 로직을 추가하고, 진입 주문과 함께 TP/SL 주문이 나가도록 개선합니다.

Phase 3: 시스템 고도화 및 안정성 강화

목표: 다중 이벤트 처리, 로깅 시스템 도입 등 24시간 안정적인 운영을 위한 내부 아키텍처 개선에 집중합니다.

세부 스코프:

[3-1] 이벤트 기반 비동기 아키텍처 도입: asyncio와 다중 큐를 사용한 이벤트 기반 아키텍처로 리팩토링하여 병목 현상을 방지합니다.

[3-2] 정식 로깅 시스템 구축: print() 문을 모두 Python의 logging 모듈로 교체하여 콘솔과 파일에 동시에 체계적인 로그를 기록합니다.

[3-3] 지정가 매매 전략 구현: 초기 전략 중 지정가(Limit Order) 매매 전략을 개발하고 관련 주문 처리 로직을 추가합니다.

[3-4] 상태 관리 기능 추가: 현재 포지션 정보, 계좌 잔고 등을 주기적으로 조회하고 내부적으로 상태를 관리하는 기반을 마련합니다.

Future Enhancements (미래 개선 사항)

웹 기반 모니터링 대시보드 UI 개발

더 다양한 ICT 기반 전략 추가 및 백테스팅 기능 도입

다중 티커 동시 거래 지원

클라우드 서버 배포 자동화 스크립트 작성

6. Logical Dependency Chain (논리적 의존성 체인)

데이터 수신이 최우선 (Foundation): 어떠한 로직도 실시간 데이터를 받지 못하면 무용지물입니다. 따라서 [1-1] API 연결 및 데이터 스트리밍은 모든 개발의 시작점입니다.

신호 생성 -> 주문 실행 (Core Flow): 데이터가 들어오면, 가장 간단한 형태라도 [1-2] 신호를 만들고 이를 [1-3] 주문으로 연결하는 흐름을 먼저 완성해야 합니다. 이 최소 기능의 파이프라인이 구축되어야 이후 각 단계를 고도화하는 작업이 의미를 가집니다.

전략 고도화 -> 리스크 관리 적용 (Adding Intelligence): 기본 파이프라인 위에서 Mock 전략을 [2-1, 2-2] 실제 ICT 전략으로 교체하고, 동시에 안전장치인 [2-3] 리스크 관리 모듈을 구현합니다. 리스크 관리는 실제 자금이 투입되기 전 반드시 구현되어야 할 필수 의존성을 가집니다.

안정성 확보 (Stabilization): 핵심 기능이 구현된 후, 시스템이 24시간 멈추지 않고 안정적으로 동작하도록 [3-1] 내부 아키텍처를 개선하고 [3-2] 로깅 시스템을 구축하는 작업이 뒤따라야 합니다. 이는 시스템의 신뢰도를 높이는 데 필수적입니다.

기능 확장 (Expansion): 안정적인 코어 시스템이 완성된 후에야 [3-3] 지정가 전략 추가나 미래 개선 사항 같은 추가 기능을 개발하여 확장성을 높여나갑니다.

7. Risks and Mitigations (리스크와 완화 방안)
7.1 기술적 리스크 (Technical Risks)

Risk: ICT 지표(FVG, Order Block 등)의 '정확한' 구현에 대한 부담감으로 인해, 모든 엣지 케이스(Edge Case)를 고려한 과도한 설계를 시도하다가 실제 동작하는 코드를 완성하지 못하고 개발이 지연될 수 있습니다.

Mitigation (완화 방안):

"동작"을 최우선 목표로 설정: 초기 개발 단계에서는 "완벽한 지표"가 아닌 "동작하는 지표"를 목표로 합니다.

보편적 정의 활용: 널리 알려진 기술적 분석 사이트나 커뮤니티에서 통용되는 표준적인 정의와 계산식을 기반으로 지표를 1차 구현합니다. Fair Value Gap이나 Order Block과 같은 개념은 3개의 캔들 관계 등 명확한 규칙을 가지고 있어 초기 구현이 용이합니다.

점진적 개선: 초기 구현으로 시스템의 전체 흐름을 먼저 테스트한 후, 실제 테스트넷 환경에서 동작하는 것을 관찰하며 필요에 따라 지표의 정교함을 점진적으로 높여 나갑니다.

7.2 시장 리스크 (Market Risks)

Risk: 급격한 시장 변동성 발생 시, 시스템이 설정한 손절 가격에 주문을 내더라도 의도보다 훨씬 불리한 가격에 체결(슬리피지)되어 계획보다 큰 손실이 발생할 수 있습니다.

Mitigation (완화 방안):

손절매 기능 구현에 집중: 초기 단계에서는 슬리피지를 완벽하게 제어하려는 복잡한 로직을 도입하지 않습니다. 대신, 바이낸스 API가 제공하는 가장 확실한 형태의 Stop-Market 주문이 반드시 실행되도록 구현하는 것에 집중합니다.

리스크의 수용: 슬리피지는 시장가 주문의 본질적인 특성임을 인지하고, 초기 단계에서는 시스템의 허용 가능한 리스크 범위로 간주합니다. 이로 인해 설계가 과도하게 복잡해지는 것을 방지하는 것이 더 중요합니다.

7.3 개발 리소스 리스크 (Development Resource Risks)

Risk: 프로젝트의 각 구성 요소 구현이 예상보다 난해하거나, 의존성이 복잡하여 작업 우선순위가 불명확해질 경우 전체 개발 기간이 크게 늘어날 수 있습니다.

Mitigation (완화 방안):

로드맵 및 의존성 준수: 본 PRD의 **5. Development Roadmap**과 **6. Logical Dependency Chain**에 정의된 개발 순서를 철저히 따릅니다. 각 단계(Phase)를 독립적인 목표로 설정하고 순차적으로 접근하여 개발의 복잡성을 관리합니다.

정교한 작업 분할: 개발 착수 전, 로드맵의 각 항목을 더 작은 실행 가능한 태스크(예: 1. FVG 계산 함수 작성, 2. 단위 테스트 코드 작성)로 세분화하여 누락 없이 계획적으로 진행합니다.

8. Appendix (부록)

[이 섹션에는 추후 프로젝트 진행 중 발생하는 리서치 자료, 상세 기술 명세, 의사결정 기록 등을 추가할 수 있습니다.]