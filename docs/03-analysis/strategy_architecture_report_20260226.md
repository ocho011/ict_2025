# 전략 설정 아키텍처 및 조립식 전략 구현 현황 분석 보고서 (상세본)

**작성일**: 2026년 2월 26일 목요일
**대상**: 트레이딩 시스템 설정 레이어 및 전략 주입 구조

---

## 서론
이 문서는 2026년 2월 26일 진행된 Gemini CLI 세션에서 논의된 트레이딩 시스템의 설정 아키텍처 문제점과 조립식 전략 구현 현황에 대한 대화를 상세하게 기록한 것입니다. 이전 요약본이 축약되었다는 피드백에 따라, 프롬프트와 답변 내용을 최대한 원본 그대로 복원하여 정리했습니다.

---

## 1. INI 파일 구조의 한계 및 아키텍처 목표 미달성 분석

### 1.1. 사용자 프롬프트
> "tradingconfig가 stratergyconfig를 포함하는 상위 계층으로 볼 수 있는데, 현재 tradingconfig.ini 파일의 구조 및 configmaniger를 통해 로딩되는 형태를 보면 tradingconfig.ini 파일의 'trading' 섹션을 통해 릴레이되는 stratergyconfig는 단지 하나일 수밖에 없어 보여. 그렇다면, 복수의 코인 각각에 대해 별도의 전략을 주입한다는 아키텍처의 목표가 충분히 달성되지 않는 것 같아. 이와 같은 이해가 맞나?"

### 1.2. Gemini CLI 답변 전문

지적하신 부분이 **이 프로젝트의 아키텍처적 부채(Technical Debt)가 가장 극명하게 드러나는 지점**이며, 이해하신 내용이 100% 맞습니다.

#### 1.2.1. 지적하신 구조적 문제의 핵심 (Bottleneck Analysis)

현재 `trading_config.ini`와 `ConfigManager`의 로직은 다음과 같은 **"1:N 릴레이 구조"**의 한계를 가지고 있습니다.

*   **현재 INI 로딩 흐름**:
    1.  `[trading]` 섹션에서 `symbols = BTCUSDT, ETHUSDT`를 읽음.
    2.  동일 섹션에서 `strategy = ict_strategy`라는 **단 하나의 전략 이름**을 읽음.
    3.  `[ict_strategy]`라는 섹션을 찾아 **단 하나의 파라미터 세트**를 읽음.
    4.  이 파라미터 세트를 리스트에 담긴 **모든 코인에 동일하게 복사**하여 주입함.

*   **결과**: BTC는 공격적으로, ETH는 보수적으로 세팅하고 싶어도 INI 파일 구조상 `[ict_strategy]` 섹션이 하나뿐이므로 불가능합니다. 이는 "코인별 독립적 전략 주입"이라는 상위 아키텍처 목표와 정면으로 충돌합니다.

#### 1.2.2. 왜 이런 모순이 방치되었는가? (Context)

프로젝트 이력을 추적해 보면, 이를 해결하기 위해 `trading_config.yaml`이라는 계층형(Hierarchical) 포맷이 도입되었습니다(`src/config/symbol_config.py`의 `TradingConfigHierarchical`). YAML 구조에서는 다음과 같이 코인별 주입이 가능하도록 설계는 되어 있습니다.

```yaml
# 이상적인 YAML 예시 (설계상 존재하지만 활용이 미비함)
symbols:
  BTCUSDT:
    strategy: ict_strategy
    strategy_params: { active_profile: strict }
  ETHUSDT:
    strategy: mock_sma
    strategy_params: { period: 20 }
```

**하지만 실질적인 문제는:**
1.  `ConfigManager`가 여전히 INI 파일을 '기본(Fallback)'으로 삼고 있어, 대부분의 로직이 INI의 평면적 구조에 갇혀 있습니다.
2.  실제 `TradingEngine`이 전략을 생성할 때, YAML의 계층 정보를 100% 활용하기보다는 INI에서 파생된 평면적 `TradingConfig` 객체를 참조하는 경우가 많습니다.

#### 1.2.3. 정밀 분석 결과: 레이어 경계가 모호한 이유

*   **상위 계층(TradingConfig)**이 **하위 계층(StrategyConfig)**의 구체적인 타입이나 코인별 차이를 담아낼 수 없는 '너무 좁은 그릇'입니다.
*   `TradingConfig`는 "어떤 코인들을 돌릴까?"라는 **운영 정보**를 담당해야 하고, `StrategyConfig`는 "이 코인을 어떻게 요리할까?"라는 **기술 정보**를 담당해야 하는데, 현재는 운영 정보 섹션(`[trading]`)에서 기술 정보(`strategy_config`)를 대표로 하나만 뽑아 전달하는 **'대표성 오류'**를 범하고 있습니다.

#### 1.2.4. 제언: "경계 명확화"를 위한 방향

이해하신 바와 같이, 현재 구조로는 아키텍처 목표 달성이 불가능하므로 다음과 같은 설계 변경이 필요합니다.

1.  **Configuration Injection 명확화**: `TradingEngine`이 전략을 생성할 때, `ConfigManager`에게 "전체 설정"을 달라고 하는 것이 아니라, **"특정 심볼에 최적화된 개별 StrategyConfig 객체"**를 요청하여 주입받는 방식으로 바뀌어야 합니다.
2.  **INI 구조 폐기 또는 확장**: INI를 유지해야 한다면 `[strategy.BTCUSDT]`와 같이 섹션을 분리하는 확장이 필요하지만, 가독성과 UI 연동을 고려하면 **YAML을 Canonical Source로 승격**시키고 INI를 완전히 걷어내는 것이 유지보수 측면에서 유리합니다.

**결론**: 지적하신 내용은 정확하며, 이는 단순한 가독성 문제를 넘어 **"개별 코인 단위의 전략적 독립성"을 가로막는 핵심 설계 결함**입니다. 설계 단계에서는 이 '릴레이 구조'를 '개별 주입 구조'로 혁파하는 것이 최우선 과제가 되어야 합니다.

---

## 2. "Relay(전달)" vs "Injection(주입)" 개념 심화

### 2.1. 사용자 프롬프트
> ""이 문제를 해결하기 위해서는 다음 단계의 설계에서 "Relay(전달)" 방식이 아닌 "Injection(주입)" 방식으로 전환해야 합니다." 부분이 잘 이해되지 않아. 풀어서 쉽게 설명해 줘."

### 2.2. Gemini CLI 답변 전문

"Relay(전달)"와 "Injection(주입)"의 차이를 일상생활의 예시로 아주 쉽게 풀어 설명해 드릴게요.

#### 2.2.1. 현재의 방식: **"Relay (단체 주문)"**
현재 시스템은 마치 **"단체 급식"**과 같습니다.

*   **동작**: 영양사(`ConfigManager`)가 식단표(`.ini` 파일)를 보고 "오늘 메뉴는 비빔밥이다"라고 결정합니다.
*   **전달**: 그리고 식당에 온 모든 학생(BTC, ETH, SOL 코인)에게 **똑같은 비빔밥(전략 파라미터)**을 한 그릇씩 나눠줍니다.
*   **한계**: 만약 BTC 학생은 "고추장을 빼달라"고 하고 싶고, ETH 학생은 "참기름을 더 넣어달라"고 해도, 영양사는 이미 한 솥에 다 비벼버린 비빔밥을 그냥 **전달(Relay)**할 뿐이라 개별 요구를 들어줄 수가 없습니다. 
*   **코드적 의미**: `TradingConfig`라는 커다란 객체 하나에 모든 코인 리스트와 단 하나의 설정값을 담아서 엔진에 통째로 던져주는 방식입니다.

#### 2.2.2. 바뀌어야 할 방식: **"Injection (개별 맞춤 주문)"**
새로운 설계는 **"오마카세 또는 개인 맞춤형 식단"**과 같아야 합니다.

*   **동작**: 셰프(`TradingEngine`)가 요리를 시작하기 전에 주문서(`ConfigManager`)에게 물어봅니다. **"지금 BTC 요리할 건데, 얘는 뭘 좋아하지?"**
*   **주입**: 주문서는 BTC만을 위해 준비된 **전용 레시피(StrategyConfig)**를 꺼내서 셰프에게 딱 전달합니다. 셰프는 그 레시피를 BTC 요리에만 **주입(Injection)**합니다.
*   **장점**: 다음 순서인 ETH 요리를 할 때는 또 물어보고, ETH 전용 레시피를 받아와서 적용합니다. 이제 BTC는 맵게, ETH는 싱겁게 만드는 것이 가능해집니다.
*   **코드적 의미**: 엔진이 설정 덩어리를 통째로 받는 게 아니라, **"특정 심볼에 딱 맞는 독립된 설정 객체"**를 그때그때 매니저로부터 받아서 전략 인스턴스에 직접 꽂아주는 방식입니다.

#### 2.2.3. 요약

*   **Relay(전달)**: "자, 여기 **공통 설정**이야. 너네 다 이거 써!" (모두가 똑같아짐)
*   **Injection(주입)**: "자, 이건 **너만을 위한 설정**이야. 이것만 보고 작동해!" (코인마다 달라짐)

"주입" 방식으로 바뀐다는 것은, **시스템이 설정을 다루는 단위가 '전체(Global)'에서 '개별 심볼(Symbol)'로 정밀해진다**는 뜻입니다. 이렇게 되어야만 사용자가 원하시는 "코인별로 전략과 수치를 다르게 최적화하는 것"이 기술적으로 완벽하게 가능해집니다.

---

## 3. 조립식 전략(Composable Strategy) 및 모듈화 현황

### 3.1. 사용자 프롬프트
> "궁극적으로 하나의 완전한 '조립식 전략'이 각 심벌에 매핑되어 트레이딩 엔진에 주입되어 '조립식 전략' 인스턴스가 생성되어야 하는 것으로 이해 돼. 그러기 위해서는 하나의 완전한 '조립식 전략'을 구성하는 모듈(예컨대, entry, exit, tp, sl의 각 가격결정자) 각각에 대한 사양 또는 클래스(예컨대, entry 가격결정자로서 a, b, c... 클래스)가 어딘가에 '미리' 정의되고, 각 모듈에 대한 클래스를 조합 내지 조립한 하나의 '완전한 전략' (예컨대, entry 가격결정자는 a 클래스, exit 가격결정자는 x 클래스, tp 가격결정자는 y 클래스, sl가격결정자는 z 클래스가 조립되어 구성된 AA라는 이름의 완전한 전략)이 각 코인에 매핑되는 구조여야 할 것 같은데. 이러한 이해가 맞나? 그리고 이러한 사항이 현재 프로젝트 상태에서 어느정도까지 구현되어 있는지?"

### 3.2. Gemini CLI 답변 전문

사용자의 이해는 **현대적인 트레이딩 시스템 아키텍처의 정점인 '객체 지향적 조립(Composition)' 방식과 100% 일치**합니다.

말씀하신 "Entry + Exit + TP + SL 모듈의 조합이 하나의 완전한 전략이 되어 심볼에 매핑되는 구조"는 이미 프로젝트 내부에서 **`ComposableStrategy`**라는 이름으로 설계 및 구현되어 있습니다.

#### 3.2.1. 사용자의 이해가 맞는지? (Yes, Correct)
정확합니다. 이를 소프트웨어 디자인 패턴에서는 **Strategy 패턴**과 **Composition(합성)**의 결합이라고 부릅니다.
*   **사양/클래스 정의**: `src/entry/`, `src/exit/`, `src/pricing/` 디렉토리에 각 모듈의 인터페이스(Base 클래스)와 구체적인 구현체(a, b, c 클래스)들이 정의되어야 합니다.
*   **전략 조립**: 이 부품들을 조립하여 `StrategyModuleConfig`라는 객체에 담고, 이를 `ComposableStrategy` 인스턴스에 주입합니다.
*   **심볼 매핑**: 이렇게 조립된 `ComposableStrategy` 인스턴스가 각 코인(BTC, ETH 등)에 1:1로 할당되어 독립적으로 작동합니다.

#### 3.2.2. 현재 프로젝트의 구현 수준 (Current Status)

현재 프로젝트는 이 아키텍처를 향해 가고 있지만, **'조립의 유연성'** 측면에서 과도기적 단계에 있습니다.

*   **A. 모듈화 수준 (구현 완료)**
    *   **부품(Determiners) 존재**: `ICTEntry`, `SMAEntry`, `PercentageStopLoss`, `RiskRewardTakeProfit` 등 개별 부품들이 클래스로 분리되어 있습니다.
    *   **조립 엔진 존재**: `src/strategies/composable.py` 파일에 부품들을 받아서 전체 흐름을 제어하는 `ComposableStrategy` 클래스가 이미 존재합니다.

*   **B. 조립 방식 (하드코딩된 빌더)**
    *   현재는 사용자가 설정 파일에서 "A+X+Y+Z"를 자유롭게 고르는 수준은 아닙니다.
    *   대신 `src/strategies/module_config_builder.py` 파일 내부에 **`_build_ict_config`**, **`_build_sma_config`**와 같은 **'고정 레시피(Builder)'**가 미리 작성되어 있습니다.
    *   즉, 사용자는 "ict_strategy"라는 이름을 선택함으로써 미리 정의된 조립 세트를 통째로 가져오는 방식입니다.

*   **C. 심볼 매핑 (병목 구간)**
    *   앞선 대화에서 분석했듯이, `trading_config.ini`를 사용하면 "모든 코인에 똑같은 조립 세트"만 주입됩니다.
    *   `trading_config.yaml`을 사용하면 코인별로 다른 조립 세트(전략 이름)를 주입할 준비는 되어 있으나, 시스템 전반의 활용도가 낮습니다.

#### 3.2.3. 향후 개선이 필요한 '정밀 설계' 포인트

사용자의 비전을 완벽히 달성하기 위해서는 다음의 구현이 추가로 필요합니다.

1.  **Dynamic Assembler (동적 조립기)**: 설정 파일에서 전략 이름뿐만 아니라, `entry: ict_entry`, `sl: percentage_sl`과 같이 **부품의 이름들을 직접 명시**하면 실시간으로 조립해 주는 기능.
2.  **Parameter Schema**: 조립된 각 부품이 요구하는 파라미터(예: SL의 퍼센트 값, Entry의 이동평균선 기간 등)를 UI에서 오류 없이 입력받을 수 있도록 하는 규격화.
3.  **Symbol-Specific Factory**: 트레이딩 엔진이 시작될 때 각 심볼을 순회하며, 해당 심볼에 매핑된 '나만의 조립 전략'을 생성하여 주입하는 팩토리 로직 강화.

**요약하자면**: 엔진과 부품은 준비되어 있으나, 이를 **설정 레이어에서 자유자재로 조립하고 코인에 꽂아주는 '연결 고리'**가 아직은 고정된 형태(Hardcoded)입니다. 이를 유연하게 만드는 것이 우리가 진행할 다음 설계의 핵심이 될 것입니다.

---

## 4. `TradingConfigHierarchical` 객체의 실체와 아키텍처적 교두보 역할

### 4.1. 구조적 의의: "1:N 릴레이" 문제를 해결하기 위한 기술적 교두보

`src/config/symbol_config.py`에 구현된 `TradingConfigHierarchical` 객체는 본 보고서 1.2.2절에서 언급한 아키텍처적 모순을 해결하기 위해 도입된 **실질적인 기술적 장치**입니다. 

*   **계층적 데이터 모델**: `defaults`(전역 기본값)와 `symbols`(심볼별 오버라이드)를 명확히 분리하여 관리합니다.
*   **심볼별 독립성 보장**: 각 심볼(BTCUSDT, ETHUSDT 등)이 자신만의 `strategy`와 `strategy_params`를 가질 수 있는 "그릇" 역할을 수행합니다.

### 4.2. 현재 구현의 한계: "데이터 보관"과 "실제 주입" 간의 간극

하지만 정밀 분석 결과, 이 객체의 존재에도 불구하고 보고서의 '아키텍처 목표 미달성' 분석은 여전히 유효합니다. 그 이유는 다음과 같습니다.

1.  **활용의 과도기성**: `ConfigManager`는 YAML 파일이 존재할 때만 이 객체를 생성하며, 파일이 없을 경우 즉시 `None`을 반환하고 과거의 평면적인 `INI` 기반 `TradingConfig`로 회귀(Fallback)합니다.
2.  **전달(Relay)의 관성**: 설령 이 객체가 생성되더라도, 하위 레이어(TradingEngine 등)에서 이를 "특정 심볼에 최적화된 개별 객체"로 **주입(Injection)**받기보다, 여전히 전체 설정 덩어리를 **전달(Relay)**받아 내부에서 파싱하는 구조가 남아있을 가능성이 큽니다.
3.  **정적 조립의 한계**: `strategy_params`가 현재는 단순한 설정값들의 딕셔너리(`Dict`) 형태입니다. 이는 보고서 3.2.3절에서 제언한 '부품 단위의 동적 조립 명세서'로까지는 아직 진화하지 못한 상태입니다.

### 4.3. 향후 고도화 방향: "Injection 엔진"으로의 승격

`TradingConfigHierarchical`은 단순한 설정 보관소를 넘어 다음과 같이 진화해야 합니다.

*   **Canonical Source화**: INI 파일을 완전히 대체하거나, INI 설정을 내부적으로 `TradingConfigHierarchical` 구조로 자동 변환하여 시스템 전반이 단일한 계층형 인터페이스만 바라보게 해야 합니다.
*   **Factory Method 결합**: 이 객체가 각 심볼의 명세(`SymbolConfig`)를 바탕으로, 실제 작동 가능한 **'조립된 전략 인스턴스'를 직접 찍어내어 엔진에 주입**하는 팩토리 역할을 수행해야 합니다.

**결론**: `TradingConfigHierarchical`은 우리가 지향하는 "심볼별 독립적 전략 주입" 아키텍처로 가기 위한 **준비된 엔진**입니다. 이제 남은 과제는 이 엔진을 시스템 전체의 로직과 강력하게 결합하여, 설정이 전략의 생성과 주입을 직접 주도하도록 만드는 것입니다.
